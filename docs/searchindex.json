{"categories":[],"posts":[{"content":"题意 对于一个n个点的无向完全图，边权是1到k的整数。\n如果这个完全图的最小生成树大小等于所有与1号点连接的边的边权和，那么称这样一个图是好的。\n求对于给定的n和k，有多少个图是好的。\ntag dp，组合数学\nsolution 首先这是一个完全图，那么所有与1号点连接的边就已经构成一颗生成树，并且这还是一颗最小生成树。\n其他的生成树就相当于去掉一条（1，i），连接一条（i，j）。\n那么思考一下什么样的图是好的，即在什么时候，边的变化不会影响最小生成树：\n得到结论，对于1，i，j这三个点，如果（i，j）\u0026gt;= max{（1，i），（1，j）}，则可以保证最小生成树要么是由与1放射状连接的那些边组成，要么是这个三角形中用（i，j）替换了另两条边之一，同时MST的大小不变。\n所以要统计的就是，对于所有（1，i）赋值后，（i，j）们满足条件的赋值方案数的总和。\n  这个用dp来求：\n$dp[i][j]$表示已经赋值的i个边中最长为j的最终方案数。\n接下来枚举赋值边长j+1的边的个数t，即从n-i个边中选出t个，这t个两两之间以及和前i个之间都需要计算边长方案。\n  n--; dp[0][1] = 1; for (int i=0;i\u0026lt;=n;++i) for (int t=0;i+t\u0026lt;=n;++t) for (int j=1;j\u0026lt;=k;++j) { dp[i+t][j+1] = ( dp[i+t][j+1] + dp[i][j]*c[n-i][t]%mod*fp(k-j+1,t*(t-1)/2+i*t)%mod )%mod; } printf(\u0026quot;%lld\\n\u0026quot;,dp[n][k+1]);  ","id":0,"section":"posts","summary":"题意 对于一个n个点的无向完全图，边权是1到k的整数。 如果这个完全图的最小生成树大小等于所有与1号点连接的边的边权和，那么称这样一个图是好的。","tags":null,"title":"CF1657E","uri":"https://13toast.github.io/2022/04/cf1657e/","year":"2022"},{"content":"Everything is ready.\n","id":1,"section":"posts","summary":"Everything is ready.","tags":null,"title":"Begin","uri":"https://13toast.github.io/2022/03/begin/","year":"2022"}],"tags":[]}